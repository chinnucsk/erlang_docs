<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- driver_entry</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../../doc/js/erlresolvelinks.js"></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small>
<a href="../apps/erts/users_guide.html">User's Guide</a><br>
<a href="../apps/erts/index.html">Reference Manual</a><br>
<a href="../apps/erts/release_notes.html">Release Notes</a><br>
<a href="../apps/erts/erts.pdf">PDF</a><br>
<a href="../index.html">Top</a></small><p><strong>Erlang Run-Time System Application (ERTS)</strong><br><strong>Reference Manual</strong><br><small>Version 5.7.4</small></p>
<br>
<a href="javascript:openAllFlips()">Expand All</a><br>
<a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li title="erl_prim_loader " expanded="false">erl_prim_loader<ul>
<li>
<a href="erl_prim_loader.html">
                  Top of manual page
                </a></li>
<li title="start-3">
<a href="erl_prim_loader.html#start-3">start/3</a></li>
<li title="get_file-1">
<a href="erl_prim_loader.html#get_file-1">get_file/1</a></li>
<li title="get_path-0">
<a href="erl_prim_loader.html#get_path-0">get_path/0</a></li>
<li title="list_dir-1">
<a href="erl_prim_loader.html#list_dir-1">list_dir/1</a></li>
<li title="read_file_info-1">
<a href="erl_prim_loader.html#read_file_info-1">read_file_info/1</a></li>
<li title="set_path-1">
<a href="erl_prim_loader.html#set_path-1">set_path/1</a></li>
</ul>
</li>
<li title="erlang " expanded="false">erlang<ul>
<li>
<a href="erlang.html">
                  Top of manual page
                </a></li>
<li title="abs-1">
<a href="erlang.html#abs-1">abs/1</a></li>
<li title="adler32-1">
<a href="erlang.html#adler32-1">adler32/1</a></li>
<li title="adler32-2">
<a href="erlang.html#adler32-2">adler32/2</a></li>
<li title="adler32_combine-3">
<a href="erlang.html#adler32_combine-3">adler32_combine/3</a></li>
<li title="erlang:append_element-2">
<a href="erlang.html#erlang:append_element-2">erlang:append_element/2</a></li>
<li title="apply-2">
<a href="erlang.html#apply-2">apply/2</a></li>
<li title="apply-3">
<a href="erlang.html#apply-3">apply/3</a></li>
<li title="atom_to_binary-2">
<a href="erlang.html#atom_to_binary-2">atom_to_binary/2</a></li>
<li title="atom_to_list-1">
<a href="erlang.html#atom_to_list-1">atom_to_list/1</a></li>
<li title="binary_to_atom-2">
<a href="erlang.html#binary_to_atom-2">binary_to_atom/2</a></li>
<li title="binary_to_existing_atom-2">
<a href="erlang.html#binary_to_existing_atom-2">binary_to_existing_atom/2</a></li>
<li title="binary_to_list-1">
<a href="erlang.html#binary_to_list-1">binary_to_list/1</a></li>
<li title="binary_to_list-3">
<a href="erlang.html#binary_to_list-3">binary_to_list/3</a></li>
<li title="bitstring_to_list-1">
<a href="erlang.html#bitstring_to_list-1">bitstring_to_list/1</a></li>
<li title="binary_to_term-1">
<a href="erlang.html#binary_to_term-1">binary_to_term/1</a></li>
<li title="bit_size-1">
<a href="erlang.html#bit_size-1">bit_size/1</a></li>
<li title="erlang:bump_reductions-1">
<a href="erlang.html#erlang:bump_reductions-1">erlang:bump_reductions/1</a></li>
<li title="byte_size-1">
<a href="erlang.html#byte_size-1">byte_size/1</a></li>
<li title="erlang:cancel_timer-1">
<a href="erlang.html#erlang:cancel_timer-1">erlang:cancel_timer/1</a></li>
<li title="check_process_code-2">
<a href="erlang.html#check_process_code-2">check_process_code/2</a></li>
<li title="concat_binary-1">
<a href="erlang.html#concat_binary-1">concat_binary/1</a></li>
<li title="crc32-1">
<a href="erlang.html#crc32-1">crc32/1</a></li>
<li title="crc32-2">
<a href="erlang.html#crc32-2">crc32/2</a></li>
<li title="crc32_combine-3">
<a href="erlang.html#crc32_combine-3">crc32_combine/3</a></li>
<li title="date-0">
<a href="erlang.html#date-0">date/0</a></li>
<li title="decode_packet-3">
<a href="erlang.html#decode_packet-3">decode_packet/3</a></li>
<li title="delete_module-1">
<a href="erlang.html#delete_module-1">delete_module/1</a></li>
<li title="erlang:demonitor-1">
<a href="erlang.html#erlang:demonitor-1">erlang:demonitor/1</a></li>
<li title="erlang:demonitor-2">
<a href="erlang.html#erlang:demonitor-2">erlang:demonitor/2</a></li>
<li title="disconnect_node-1">
<a href="erlang.html#disconnect_node-1">disconnect_node/1</a></li>
<li title="erlang:display-1">
<a href="erlang.html#erlang:display-1">erlang:display/1</a></li>
<li title="element-2">
<a href="erlang.html#element-2">element/2</a></li>
<li title="erase-0">
<a href="erlang.html#erase-0">erase/0</a></li>
<li title="erase-1">
<a href="erlang.html#erase-1">erase/1</a></li>
<li title="erlang:error-1">
<a href="erlang.html#erlang:error-1">erlang:error/1</a></li>
<li title="erlang:error-2">
<a href="erlang.html#erlang:error-2">erlang:error/2</a></li>
<li title="exit-1">
<a href="erlang.html#exit-1">exit/1</a></li>
<li title="exit-2">
<a href="erlang.html#exit-2">exit/2</a></li>
<li title="float-1">
<a href="erlang.html#float-1">float/1</a></li>
<li title="float_to_list-1">
<a href="erlang.html#float_to_list-1">float_to_list/1</a></li>
<li title="erlang:fun_info-1">
<a href="erlang.html#erlang:fun_info-1">erlang:fun_info/1</a></li>
<li title="erlang:fun_info-2">
<a href="erlang.html#erlang:fun_info-2">erlang:fun_info/2</a></li>
<li title="erlang:fun_to_list-1">
<a href="erlang.html#erlang:fun_to_list-1">erlang:fun_to_list/1</a></li>
<li title="erlang:function_exported-3">
<a href="erlang.html#erlang:function_exported-3">erlang:function_exported/3</a></li>
<li title="garbage_collect-0">
<a href="erlang.html#garbage_collect-0">garbage_collect/0</a></li>
<li title="garbage_collect-1">
<a href="erlang.html#garbage_collect-1">garbage_collect/1</a></li>
<li title="get-0">
<a href="erlang.html#get-0">get/0</a></li>
<li title="get-1">
<a href="erlang.html#get-1">get/1</a></li>
<li title="erlang:get_cookie-0">
<a href="erlang.html#erlang:get_cookie-0">erlang:get_cookie/0</a></li>
<li title="get_keys-1">
<a href="erlang.html#get_keys-1">get_keys/1</a></li>
<li title="erlang:get_stacktrace-0">
<a href="erlang.html#erlang:get_stacktrace-0">erlang:get_stacktrace/0</a></li>
<li title="group_leader-0">
<a href="erlang.html#group_leader-0">group_leader/0</a></li>
<li title="group_leader-2">
<a href="erlang.html#group_leader-2">group_leader/2</a></li>
<li title="halt-0">
<a href="erlang.html#halt-0">halt/0</a></li>
<li title="halt-1">
<a href="erlang.html#halt-1">halt/1</a></li>
<li title="erlang:hash-2">
<a href="erlang.html#erlang:hash-2">erlang:hash/2</a></li>
<li title="hd-1">
<a href="erlang.html#hd-1">hd/1</a></li>
<li title="erlang:hibernate-3">
<a href="erlang.html#erlang:hibernate-3">erlang:hibernate/3</a></li>
<li title="integer_to_list-1">
<a href="erlang.html#integer_to_list-1">integer_to_list/1</a></li>
<li title="erlang:integer_to_list-2">
<a href="erlang.html#erlang:integer_to_list-2">erlang:integer_to_list/2</a></li>
<li title="iolist_to_binary-1">
<a href="erlang.html#iolist_to_binary-1">iolist_to_binary/1</a></li>
<li title="iolist_size-1">
<a href="erlang.html#iolist_size-1">iolist_size/1</a></li>
<li title="is_alive-0">
<a href="erlang.html#is_alive-0">is_alive/0</a></li>
<li title="is_atom-1">
<a href="erlang.html#is_atom-1">is_atom/1</a></li>
<li title="is_binary-1">
<a href="erlang.html#is_binary-1">is_binary/1</a></li>
<li title="is_bitstring-1">
<a href="erlang.html#is_bitstring-1">is_bitstring/1</a></li>
<li title="is_boolean-1">
<a href="erlang.html#is_boolean-1">is_boolean/1</a></li>
<li title="erlang:is_builtin-3">
<a href="erlang.html#erlang:is_builtin-3">erlang:is_builtin/3</a></li>
<li title="is_float-1">
<a href="erlang.html#is_float-1">is_float/1</a></li>
<li title="is_function-1">
<a href="erlang.html#is_function-1">is_function/1</a></li>
<li title="is_function-2">
<a href="erlang.html#is_function-2">is_function/2</a></li>
<li title="is_integer-1">
<a href="erlang.html#is_integer-1">is_integer/1</a></li>
<li title="is_list-1">
<a href="erlang.html#is_list-1">is_list/1</a></li>
<li title="is_number-1">
<a href="erlang.html#is_number-1">is_number/1</a></li>
<li title="is_pid-1">
<a href="erlang.html#is_pid-1">is_pid/1</a></li>
<li title="is_port-1">
<a href="erlang.html#is_port-1">is_port/1</a></li>
<li title="is_process_alive-1">
<a href="erlang.html#is_process_alive-1">is_process_alive/1</a></li>
<li title="is_record-2">
<a href="erlang.html#is_record-2">is_record/2</a></li>
<li title="is_record-3">
<a href="erlang.html#is_record-3">is_record/3</a></li>
<li title="is_reference-1">
<a href="erlang.html#is_reference-1">is_reference/1</a></li>
<li title="is_tuple-1">
<a href="erlang.html#is_tuple-1">is_tuple/1</a></li>
<li title="length-1">
<a href="erlang.html#length-1">length/1</a></li>
<li title="link-1">
<a href="erlang.html#link-1">link/1</a></li>
<li title="list_to_atom-1">
<a href="erlang.html#list_to_atom-1">list_to_atom/1</a></li>
<li title="list_to_binary-1">
<a href="erlang.html#list_to_binary-1">list_to_binary/1</a></li>
<li title="list_to_bitstring-1">
<a href="erlang.html#list_to_bitstring-1">list_to_bitstring/1</a></li>
<li title="list_to_existing_atom-1">
<a href="erlang.html#list_to_existing_atom-1">list_to_existing_atom/1</a></li>
<li title="list_to_float-1">
<a href="erlang.html#list_to_float-1">list_to_float/1</a></li>
<li title="list_to_integer-1">
<a href="erlang.html#list_to_integer-1">list_to_integer/1</a></li>
<li title="erlang:list_to_integer-2">
<a href="erlang.html#erlang:list_to_integer-2">erlang:list_to_integer/2</a></li>
<li title="list_to_pid-1">
<a href="erlang.html#list_to_pid-1">list_to_pid/1</a></li>
<li title="list_to_tuple-1">
<a href="erlang.html#list_to_tuple-1">list_to_tuple/1</a></li>
<li title="load_module-2">
<a href="erlang.html#load_module-2">load_module/2</a></li>
<li title="erlang:load_nif-2">
<a href="erlang.html#erlang:load_nif-2">erlang:load_nif/2</a></li>
<li title="erlang:loaded-0">
<a href="erlang.html#erlang:loaded-0">erlang:loaded/0</a></li>
<li title="erlang:localtime-0">
<a href="erlang.html#erlang:localtime-0">erlang:localtime/0</a></li>
<li title="erlang:localtime_to_universaltime-2">
<a href="erlang.html#erlang:localtime_to_universaltime-2">erlang:localtime_to_universaltime/2</a></li>
<li title="erlang:localtime_to_universaltime-3">
<a href="erlang.html#erlang:localtime_to_universaltime-3">erlang:localtime_to_universaltime/3</a></li>
<li title="make_ref-0">
<a href="erlang.html#make_ref-0">make_ref/0</a></li>
<li title="erlang:make_tuple-2">
<a href="erlang.html#erlang:make_tuple-2">erlang:make_tuple/2</a></li>
<li title="erlang:make_tuple-3">
<a href="erlang.html#erlang:make_tuple-3">erlang:make_tuple/3</a></li>
<li title="erlang:max-2">
<a href="erlang.html#erlang:max-2">erlang:max/2</a></li>
<li title="erlang:md5-1">
<a href="erlang.html#erlang:md5-1">erlang:md5/1</a></li>
<li title="erlang:md5_final-1">
<a href="erlang.html#erlang:md5_final-1">erlang:md5_final/1</a></li>
<li title="erlang:md5_init-0">
<a href="erlang.html#erlang:md5_init-0">erlang:md5_init/0</a></li>
<li title="erlang:md5_update-2">
<a href="erlang.html#erlang:md5_update-2">erlang:md5_update/2</a></li>
<li title="erlang:memory-0">
<a href="erlang.html#erlang:memory-0">erlang:memory/0</a></li>
<li title="erlang:memory-1">
<a href="erlang.html#erlang:memory-1">erlang:memory/1</a></li>
<li title="erlang:min-2">
<a href="erlang.html#erlang:min-2">erlang:min/2</a></li>
<li title="module_loaded-1">
<a href="erlang.html#module_loaded-1">module_loaded/1</a></li>
<li title="erlang:monitor-2">
<a href="erlang.html#erlang:monitor-2">erlang:monitor/2</a></li>
<li title="monitor_node-2">
<a href="erlang.html#monitor_node-2">monitor_node/2</a></li>
<li title="erlang:monitor_node-3">
<a href="erlang.html#erlang:monitor_node-3">erlang:monitor_node/3</a></li>
<li title="node-0">
<a href="erlang.html#node-0">node/0</a></li>
<li title="node-1">
<a href="erlang.html#node-1">node/1</a></li>
<li title="nodes-0">
<a href="erlang.html#nodes-0">nodes/0</a></li>
<li title="nodes-1">
<a href="erlang.html#nodes-1">nodes/1</a></li>
<li title="now-0">
<a href="erlang.html#now-0">now/0</a></li>
<li title="open_port-2">
<a href="erlang.html#open_port-2">open_port/2</a></li>
<li title="erlang:phash-2">
<a href="erlang.html#erlang:phash-2">erlang:phash/2</a></li>
<li title="erlang:phash2-2">
<a href="erlang.html#erlang:phash2-2">erlang:phash2/2</a></li>
<li title="pid_to_list-1">
<a href="erlang.html#pid_to_list-1">pid_to_list/1</a></li>
<li title="port_close-1">
<a href="erlang.html#port_close-1">port_close/1</a></li>
<li title="port_command-2">
<a href="erlang.html#port_command-2">port_command/2</a></li>
<li title="erlang:port_command-3">
<a href="erlang.html#erlang:port_command-3">erlang:port_command/3</a></li>
<li title="port_connect-2">
<a href="erlang.html#port_connect-2">port_connect/2</a></li>
<li title="port_control-3">
<a href="erlang.html#port_control-3">port_control/3</a></li>
<li title="erlang:port_call-3">
<a href="erlang.html#erlang:port_call-3">erlang:port_call/3</a></li>
<li title="erlang:port_info-1">
<a href="erlang.html#erlang:port_info-1">erlang:port_info/1</a></li>
<li title="erlang:port_info-2">
<a href="erlang.html#erlang:port_info-2">erlang:port_info/2</a></li>
<li title="erlang:port_to_list-1">
<a href="erlang.html#erlang:port_to_list-1">erlang:port_to_list/1</a></li>
<li title="erlang:ports-0">
<a href="erlang.html#erlang:ports-0">erlang:ports/0</a></li>
<li title="pre_loaded-0">
<a href="erlang.html#pre_loaded-0">pre_loaded/0</a></li>
<li title="erlang:process_display-2">
<a href="erlang.html#erlang:process_display-2">erlang:process_display/2</a></li>
<li title="process_flag-2">
<a href="erlang.html#process_flag-2">process_flag/2</a></li>
<li title="process_flag-3">
<a href="erlang.html#process_flag-3">process_flag/3</a></li>
<li title="process_info-1">
<a href="erlang.html#process_info-1">process_info/1</a></li>
<li title="process_info-2">
<a href="erlang.html#process_info-2">process_info/2</a></li>
<li title="processes-0">
<a href="erlang.html#processes-0">processes/0</a></li>
<li title="purge_module-1">
<a href="erlang.html#purge_module-1">purge_module/1</a></li>
<li title="put-2">
<a href="erlang.html#put-2">put/2</a></li>
<li title="erlang:raise-3">
<a href="erlang.html#erlang:raise-3">erlang:raise/3</a></li>
<li title="erlang:read_timer-1">
<a href="erlang.html#erlang:read_timer-1">erlang:read_timer/1</a></li>
<li title="erlang:ref_to_list-1">
<a href="erlang.html#erlang:ref_to_list-1">erlang:ref_to_list/1</a></li>
<li title="register-2">
<a href="erlang.html#register-2">register/2</a></li>
<li title="registered-0">
<a href="erlang.html#registered-0">registered/0</a></li>
<li title="erlang:resume_process-1">
<a href="erlang.html#erlang:resume_process-1">erlang:resume_process/1</a></li>
<li title="round-1">
<a href="erlang.html#round-1">round/1</a></li>
<li title="self-0">
<a href="erlang.html#self-0">self/0</a></li>
<li title="erlang:send-2">
<a href="erlang.html#erlang:send-2">erlang:send/2</a></li>
<li title="erlang:send-3">
<a href="erlang.html#erlang:send-3">erlang:send/3</a></li>
<li title="erlang:send_after-3">
<a href="erlang.html#erlang:send_after-3">erlang:send_after/3</a></li>
<li title="erlang:send_nosuspend-2">
<a href="erlang.html#erlang:send_nosuspend-2">erlang:send_nosuspend/2</a></li>
<li title="erlang:send_nosuspend-3">
<a href="erlang.html#erlang:send_nosuspend-3">erlang:send_nosuspend/3</a></li>
<li title="erlang:set_cookie-2">
<a href="erlang.html#erlang:set_cookie-2">erlang:set_cookie/2</a></li>
<li title="setelement-3">
<a href="erlang.html#setelement-3">setelement/3</a></li>
<li title="size-1">
<a href="erlang.html#size-1">size/1</a></li>
<li title="spawn-1">
<a href="erlang.html#spawn-1">spawn/1</a></li>
<li title="spawn-2">
<a href="erlang.html#spawn-2">spawn/2</a></li>
<li title="spawn-3">
<a href="erlang.html#spawn-3">spawn/3</a></li>
<li title="spawn-4">
<a href="erlang.html#spawn-4">spawn/4</a></li>
<li title="spawn_link-1">
<a href="erlang.html#spawn_link-1">spawn_link/1</a></li>
<li title="spawn_link-2">
<a href="erlang.html#spawn_link-2">spawn_link/2</a></li>
<li title="spawn_link-3">
<a href="erlang.html#spawn_link-3">spawn_link/3</a></li>
<li title="spawn_link-4">
<a href="erlang.html#spawn_link-4">spawn_link/4</a></li>
<li title="spawn_monitor-1">
<a href="erlang.html#spawn_monitor-1">spawn_monitor/1</a></li>
<li title="spawn_monitor-3">
<a href="erlang.html#spawn_monitor-3">spawn_monitor/3</a></li>
<li title="spawn_opt-2">
<a href="erlang.html#spawn_opt-2">spawn_opt/2</a></li>
<li title="spawn_opt-3">
<a href="erlang.html#spawn_opt-3">spawn_opt/3</a></li>
<li title="spawn_opt-4">
<a href="erlang.html#spawn_opt-4">spawn_opt/4</a></li>
<li title="spawn_opt-5">
<a href="erlang.html#spawn_opt-5">spawn_opt/5</a></li>
<li title="split_binary-2">
<a href="erlang.html#split_binary-2">split_binary/2</a></li>
<li title="erlang:start_timer-3">
<a href="erlang.html#erlang:start_timer-3">erlang:start_timer/3</a></li>
<li title="statistics-1">
<a href="erlang.html#statistics-1">statistics/1</a></li>
<li title="erlang:suspend_process-2">
<a href="erlang.html#erlang:suspend_process-2">erlang:suspend_process/2</a></li>
<li title="erlang:suspend_process-1">
<a href="erlang.html#erlang:suspend_process-1">erlang:suspend_process/1</a></li>
<li title="erlang:system_flag-2">
<a href="erlang.html#erlang:system_flag-2">erlang:system_flag/2</a></li>
<li title="erlang:system_info-1">
<a href="erlang.html#erlang:system_info-1">erlang:system_info/1</a></li>
<li title="erlang:system_monitor-0">
<a href="erlang.html#erlang:system_monitor-0">erlang:system_monitor/0</a></li>
<li title="erlang:system_monitor-2">
<a href="erlang.html#erlang:system_monitor-2">erlang:system_monitor/2</a></li>
<li title="erlang:system_monitor-2">
<a href="erlang.html#erlang:system_monitor-2">erlang:system_monitor/2</a></li>
<li title="erlang:system_profile-0">
<a href="erlang.html#erlang:system_profile-0">erlang:system_profile/0</a></li>
<li title="erlang:system_profile-2">
<a href="erlang.html#erlang:system_profile-2">erlang:system_profile/2</a></li>
<li title="term_to_binary-1">
<a href="erlang.html#term_to_binary-1">term_to_binary/1</a></li>
<li title="term_to_binary-2">
<a href="erlang.html#term_to_binary-2">term_to_binary/2</a></li>
<li title="throw-1">
<a href="erlang.html#throw-1">throw/1</a></li>
<li title="time-0">
<a href="erlang.html#time-0">time/0</a></li>
<li title="tl-1">
<a href="erlang.html#tl-1">tl/1</a></li>
<li title="erlang:trace-3">
<a href="erlang.html#erlang:trace-3">erlang:trace/3</a></li>
<li title="erlang:trace_delivered-1">
<a href="erlang.html#erlang:trace_delivered-1">erlang:trace_delivered/1</a></li>
<li title="erlang:trace_info-2">
<a href="erlang.html#erlang:trace_info-2">erlang:trace_info/2</a></li>
<li title="erlang:trace_pattern-2">
<a href="erlang.html#erlang:trace_pattern-2">erlang:trace_pattern/2</a></li>
<li title="erlang:trace_pattern-3">
<a href="erlang.html#erlang:trace_pattern-3">erlang:trace_pattern/3</a></li>
<li title="trunc-1">
<a href="erlang.html#trunc-1">trunc/1</a></li>
<li title="tuple_size-1">
<a href="erlang.html#tuple_size-1">tuple_size/1</a></li>
<li title="tuple_to_list-1">
<a href="erlang.html#tuple_to_list-1">tuple_to_list/1</a></li>
<li title="erlang:universaltime-0">
<a href="erlang.html#erlang:universaltime-0">erlang:universaltime/0</a></li>
<li title="erlang:universaltime_to_localtime-2">
<a href="erlang.html#erlang:universaltime_to_localtime-2">erlang:universaltime_to_localtime/2</a></li>
<li title="unlink-1">
<a href="erlang.html#unlink-1">unlink/1</a></li>
<li title="unregister-1">
<a href="erlang.html#unregister-1">unregister/1</a></li>
<li title="whereis-1">
<a href="erlang.html#whereis-1">whereis/1</a></li>
<li title="erlang:yield-0">
<a href="erlang.html#erlang:yield-0">erlang:yield/0</a></li>
</ul>
</li>
<li title="init " expanded="false">init<ul>
<li>
<a href="init.html">
                  Top of manual page
                </a></li>
<li title="boot-1">
<a href="init.html#boot-1">boot/1</a></li>
<li title="get_args-0">
<a href="init.html#get_args-0">get_args/0</a></li>
<li title="get_argument-1">
<a href="init.html#get_argument-1">get_argument/1</a></li>
<li title="get_arguments-0">
<a href="init.html#get_arguments-0">get_arguments/0</a></li>
<li title="get_plain_arguments-0">
<a href="init.html#get_plain_arguments-0">get_plain_arguments/0</a></li>
<li title="get_status-0">
<a href="init.html#get_status-0">get_status/0</a></li>
<li title="reboot-0">
<a href="init.html#reboot-0">reboot/0</a></li>
<li title="restart-0">
<a href="init.html#restart-0">restart/0</a></li>
<li title="script_id-0">
<a href="init.html#script_id-0">script_id/0</a></li>
<li title="stop-0">
<a href="init.html#stop-0">stop/0</a></li>
<li title="stop-1">
<a href="init.html#stop-1">stop/1</a></li>
</ul>
</li>
<li title="zlib " expanded="false">zlib<ul>
<li>
<a href="zlib.html">
                  Top of manual page
                </a></li>
<li title="open-0">
<a href="zlib.html#open-0">open/0</a></li>
<li title="close-1">
<a href="zlib.html#close-1">close/1</a></li>
<li title="deflateInit-1">
<a href="zlib.html#deflateInit-1">deflateInit/1</a></li>
<li title="deflateInit-2">
<a href="zlib.html#deflateInit-2">deflateInit/2</a></li>
<li title="deflateInit-6">
<a href="zlib.html#deflateInit-6">deflateInit/6</a></li>
<li title="deflate-2">
<a href="zlib.html#deflate-2">deflate/2</a></li>
<li title="deflate-3">
<a href="zlib.html#deflate-3">deflate/3</a></li>
<li title="deflateSetDictionary-2">
<a href="zlib.html#deflateSetDictionary-2">deflateSetDictionary/2</a></li>
<li title="deflateReset-1">
<a href="zlib.html#deflateReset-1">deflateReset/1</a></li>
<li title="deflateParams-3">
<a href="zlib.html#deflateParams-3">deflateParams/3</a></li>
<li title="deflateEnd-1">
<a href="zlib.html#deflateEnd-1">deflateEnd/1</a></li>
<li title="inflateInit-1">
<a href="zlib.html#inflateInit-1">inflateInit/1</a></li>
<li title="inflateInit-2">
<a href="zlib.html#inflateInit-2">inflateInit/2</a></li>
<li title="inflate-2">
<a href="zlib.html#inflate-2">inflate/2</a></li>
<li title="inflateSetDictionary-2">
<a href="zlib.html#inflateSetDictionary-2">inflateSetDictionary/2</a></li>
<li title="inflateReset-1">
<a href="zlib.html#inflateReset-1">inflateReset/1</a></li>
<li title="inflateEnd-1">
<a href="zlib.html#inflateEnd-1">inflateEnd/1</a></li>
<li title="setBufSize-2">
<a href="zlib.html#setBufSize-2">setBufSize/2</a></li>
<li title="getBufSize-1">
<a href="zlib.html#getBufSize-1">getBufSize/1</a></li>
<li title="crc32-1">
<a href="zlib.html#crc32-1">crc32/1</a></li>
<li title="crc32-2">
<a href="zlib.html#crc32-2">crc32/2</a></li>
<li title="crc32-3">
<a href="zlib.html#crc32-3">crc32/3</a></li>
<li title="crc32_combine-4">
<a href="zlib.html#crc32_combine-4">crc32_combine/4</a></li>
<li title="adler32-2">
<a href="zlib.html#adler32-2">adler32/2</a></li>
<li title="adler32-3">
<a href="zlib.html#adler32-3">adler32/3</a></li>
<li title="adler32_combine-4">
<a href="zlib.html#adler32_combine-4">adler32_combine/4</a></li>
<li title="compress-1">
<a href="zlib.html#compress-1">compress/1</a></li>
<li title="uncompress-1">
<a href="zlib.html#uncompress-1">uncompress/1</a></li>
<li title="zip-1">
<a href="zlib.html#zip-1">zip/1</a></li>
<li title="unzip-1">
<a href="zlib.html#unzip-1">unzip/1</a></li>
<li title="gzip-1">
<a href="zlib.html#gzip-1">gzip/1</a></li>
<li title="gunzip-1">
<a href="zlib.html#gunzip-1">gunzip/1</a></li>
</ul>
</li>
<li title="epmd">
<a href="epmd.html">epmd</a></li>
<li title="erl">
<a href="erl.html">erl</a></li>
<li title="erlc">
<a href="erlc.html">erlc</a></li>
<li title="werl">
<a href="werl.html">werl</a></li>
<li title="escript">
<a href="escript.html">escript</a></li>
<li title="erlsrv">
<a href="erlsrv.html">erlsrv</a></li>
<li title="start_erl">
<a href="start_erl.html">start_erl</a></li>
<li title="erl_set_memory_block " expanded="false">erl_set_memory_block<ul>
<li>
<a href="erl_set_memory_block.html">
                  Top of manual page
                </a></li>
<li title="erl_set_memory_block">
<a href="erl_set_memory_block.html#erl_set_memory_block">erl_set_memory_block()
              </a></li>
<li title="erl_memory_show">
<a href="erl_set_memory_block.html#erl_memory_show">erl_memory_show()
              </a></li>
<li title="erl_mem_info_get">
<a href="erl_set_memory_block.html#erl_mem_info_get">erl_mem_info_get()
              </a></li>
</ul>
</li>
<li title="run_erl">
<a href="run_erl.html">run_erl</a></li>
<li title="start">
<a href="start.html">start</a></li>
<li title="erl_driver " expanded="false">erl_driver<ul>
<li>
<a href="erl_driver.html">
                  Top of manual page
                </a></li>
<li title="driver_system_info">
<a href="erl_driver.html#driver_system_info">driver_system_info()
              </a></li>
<li title="driver_output">
<a href="erl_driver.html#driver_output">driver_output()
              </a></li>
<li title="driver_output2">
<a href="erl_driver.html#driver_output2">driver_output2()
              </a></li>
<li title="driver_output_binary">
<a href="erl_driver.html#driver_output_binary">driver_output_binary()
              </a></li>
<li title="driver_outputv">
<a href="erl_driver.html#driver_outputv">driver_outputv()
              </a></li>
<li title="driver_vec_to_buf">
<a href="erl_driver.html#driver_vec_to_buf">driver_vec_to_buf()
              </a></li>
<li title="driver_set_timer">
<a href="erl_driver.html#driver_set_timer">driver_set_timer()
              </a></li>
<li title="driver_cancel_timer">
<a href="erl_driver.html#driver_cancel_timer">driver_cancel_timer()
              </a></li>
<li title="driver_read_timer">
<a href="erl_driver.html#driver_read_timer">driver_read_timer()
              </a></li>
<li title="driver_get_now">
<a href="erl_driver.html#driver_get_now">driver_get_now()
              </a></li>
<li title="driver_select">
<a href="erl_driver.html#driver_select">driver_select()
              </a></li>
<li title="driver_alloc">
<a href="erl_driver.html#driver_alloc">driver_alloc()
              </a></li>
<li title="driver_realloc">
<a href="erl_driver.html#driver_realloc">driver_realloc()
              </a></li>
<li title="driver_free">
<a href="erl_driver.html#driver_free">driver_free()
              </a></li>
<li title="driver_alloc_binary">
<a href="erl_driver.html#driver_alloc_binary">driver_alloc_binary()
              </a></li>
<li title="driver_realloc_binary">
<a href="erl_driver.html#driver_realloc_binary">driver_realloc_binary()
              </a></li>
<li title="driver_free_binary">
<a href="erl_driver.html#driver_free_binary">driver_free_binary()
              </a></li>
<li title="driver_binary_get_refc">
<a href="erl_driver.html#driver_binary_get_refc">driver_binary_get_refc()
              </a></li>
<li title="driver_binary_inc_refc">
<a href="erl_driver.html#driver_binary_inc_refc">driver_binary_inc_refc()
              </a></li>
<li title="driver_binary_dec_refc">
<a href="erl_driver.html#driver_binary_dec_refc">driver_binary_dec_refc()
              </a></li>
<li title="driver_enq">
<a href="erl_driver.html#driver_enq">driver_enq()
              </a></li>
<li title="driver_pushq">
<a href="erl_driver.html#driver_pushq">driver_pushq()
              </a></li>
<li title="driver_deq">
<a href="erl_driver.html#driver_deq">driver_deq()
              </a></li>
<li title="driver_sizeq">
<a href="erl_driver.html#driver_sizeq">driver_sizeq()
              </a></li>
<li title="driver_enq_bin">
<a href="erl_driver.html#driver_enq_bin">driver_enq_bin()
              </a></li>
<li title="driver_pushq_bin">
<a href="erl_driver.html#driver_pushq_bin">driver_pushq_bin()
              </a></li>
<li title="driver_peekq">
<a href="erl_driver.html#driver_peekq">driver_peekq()
              </a></li>
<li title="driver_enqv">
<a href="erl_driver.html#driver_enqv">driver_enqv()
              </a></li>
<li title="driver_pushqv">
<a href="erl_driver.html#driver_pushqv">driver_pushqv()
              </a></li>
<li title="driver_pdl_create">
<a href="erl_driver.html#driver_pdl_create">driver_pdl_create()
              </a></li>
<li title="driver_pdl_lock">
<a href="erl_driver.html#driver_pdl_lock">driver_pdl_lock()
              </a></li>
<li title="driver_pdl_unlock">
<a href="erl_driver.html#driver_pdl_unlock">driver_pdl_unlock()
              </a></li>
<li title="driver_pdl_get_refc">
<a href="erl_driver.html#driver_pdl_get_refc">driver_pdl_get_refc()
              </a></li>
<li title="driver_pdl_inc_refc">
<a href="erl_driver.html#driver_pdl_inc_refc">driver_pdl_inc_refc()
              </a></li>
<li title="driver_pdl_dec_refc">
<a href="erl_driver.html#driver_pdl_dec_refc">driver_pdl_dec_refc()
              </a></li>
<li title="driver_monitor_process">
<a href="erl_driver.html#driver_monitor_process">driver_monitor_process()
              </a></li>
<li title="driver_demonitor_process">
<a href="erl_driver.html#driver_demonitor_process">driver_demonitor_process()
              </a></li>
<li title="driver_get_monitored_process">
<a href="erl_driver.html#driver_get_monitored_process">driver_get_monitored_process()
              </a></li>
<li title="driver_compare_monitors">
<a href="erl_driver.html#driver_compare_monitors">driver_compare_monitors()
              </a></li>
<li title="add_driver_entry">
<a href="erl_driver.html#add_driver_entry">add_driver_entry()
              </a></li>
<li title="remove_driver_entry">
<a href="erl_driver.html#remove_driver_entry">remove_driver_entry()
              </a></li>
<li title="erl_errno_id">
<a href="erl_driver.html#erl_errno_id">erl_errno_id()
              </a></li>
<li title="set_busy_port">
<a href="erl_driver.html#set_busy_port">set_busy_port()
              </a></li>
<li title="set_port_control_flags">
<a href="erl_driver.html#set_port_control_flags">set_port_control_flags()
              </a></li>
<li title="driver_failure_eof">
<a href="erl_driver.html#driver_failure_eof">driver_failure_eof()
              </a></li>
<li title="driver_failure_atom">
<a href="erl_driver.html#driver_failure_atom">driver_failure_atom()
              </a></li>
<li title="driver_failure_posix">
<a href="erl_driver.html#driver_failure_posix">driver_failure_posix()
              </a></li>
<li title="driver_failure">
<a href="erl_driver.html#driver_failure">driver_failure()
              </a></li>
<li title="driver_connected">
<a href="erl_driver.html#driver_connected">driver_connected()
              </a></li>
<li title="driver_caller">
<a href="erl_driver.html#driver_caller">driver_caller()
              </a></li>
<li title="driver_output_term">
<a href="erl_driver.html#driver_output_term">driver_output_term()
              </a></li>
<li title="driver_mk_atom">
<a href="erl_driver.html#driver_mk_atom">driver_mk_atom()
              </a></li>
<li title="driver_mk_port">
<a href="erl_driver.html#driver_mk_port">driver_mk_port()
              </a></li>
<li title="driver_send_term">
<a href="erl_driver.html#driver_send_term">driver_send_term()
              </a></li>
<li title="driver_async ">
<a href="erl_driver.html#driver_async%20">driver_async ()
              </a></li>
<li title="driver_async_cancel">
<a href="erl_driver.html#driver_async_cancel">driver_async_cancel()
              </a></li>
<li title="driver_lock_driver">
<a href="erl_driver.html#driver_lock_driver">driver_lock_driver()
              </a></li>
<li title="driver_create_port">
<a href="erl_driver.html#driver_create_port">driver_create_port()
              </a></li>
<li title="erl_drv_thread_create">
<a href="erl_driver.html#erl_drv_thread_create">erl_drv_thread_create()
              </a></li>
<li title="erl_drv_thread_opts_create">
<a href="erl_driver.html#erl_drv_thread_opts_create">erl_drv_thread_opts_create()
              </a></li>
<li title="erl_drv_thread_opts_destroy">
<a href="erl_driver.html#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy()
              </a></li>
<li title="erl_drv_thread_exit">
<a href="erl_driver.html#erl_drv_thread_exit">erl_drv_thread_exit()
              </a></li>
<li title="erl_drv_thread_join">
<a href="erl_driver.html#erl_drv_thread_join">erl_drv_thread_join()
              </a></li>
<li title="erl_drv_thread_self">
<a href="erl_driver.html#erl_drv_thread_self">erl_drv_thread_self()
              </a></li>
<li title="erl_drv_equal_tids">
<a href="erl_driver.html#erl_drv_equal_tids">erl_drv_equal_tids()
              </a></li>
<li title="erl_drv_mutex_create">
<a href="erl_driver.html#erl_drv_mutex_create">erl_drv_mutex_create()
              </a></li>
<li title="erl_drv_mutex_destroy">
<a href="erl_driver.html#erl_drv_mutex_destroy">erl_drv_mutex_destroy()
              </a></li>
<li title="erl_drv_mutex_lock">
<a href="erl_driver.html#erl_drv_mutex_lock">erl_drv_mutex_lock()
              </a></li>
<li title="erl_drv_mutex_trylock">
<a href="erl_driver.html#erl_drv_mutex_trylock">erl_drv_mutex_trylock()
              </a></li>
<li title="erl_drv_mutex_unlock">
<a href="erl_driver.html#erl_drv_mutex_unlock">erl_drv_mutex_unlock()
              </a></li>
<li title="erl_drv_cond_create">
<a href="erl_driver.html#erl_drv_cond_create">erl_drv_cond_create()
              </a></li>
<li title="erl_drv_cond_destroy">
<a href="erl_driver.html#erl_drv_cond_destroy">erl_drv_cond_destroy()
              </a></li>
<li title="erl_drv_cond_signal">
<a href="erl_driver.html#erl_drv_cond_signal">erl_drv_cond_signal()
              </a></li>
<li title="erl_drv_cond_broadcast">
<a href="erl_driver.html#erl_drv_cond_broadcast">erl_drv_cond_broadcast()
              </a></li>
<li title="erl_drv_cond_wait">
<a href="erl_driver.html#erl_drv_cond_wait">erl_drv_cond_wait()
              </a></li>
<li title="erl_drv_rwlock_create">
<a href="erl_driver.html#erl_drv_rwlock_create">erl_drv_rwlock_create()
              </a></li>
<li title="erl_drv_rwlock_destroy">
<a href="erl_driver.html#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy()
              </a></li>
<li title="erl_drv_rwlock_rlock">
<a href="erl_driver.html#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock()
              </a></li>
<li title="erl_drv_rwlock_tryrlock">
<a href="erl_driver.html#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock()
              </a></li>
<li title="erl_drv_rwlock_runlock">
<a href="erl_driver.html#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock()
              </a></li>
<li title="erl_drv_rwlock_rwlock">
<a href="erl_driver.html#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock()
              </a></li>
<li title="erl_drv_rwlock_tryrwlock">
<a href="erl_driver.html#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock()
              </a></li>
<li title="erl_drv_rwlock_rwunlock">
<a href="erl_driver.html#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock()
              </a></li>
<li title="erl_drv_tsd_key_create">
<a href="erl_driver.html#erl_drv_tsd_key_create">erl_drv_tsd_key_create()
              </a></li>
<li title="erl_drv_tsd_key_destroy">
<a href="erl_driver.html#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy()
              </a></li>
<li title="erl_drv_tsd_set">
<a href="erl_driver.html#erl_drv_tsd_set">erl_drv_tsd_set()
              </a></li>
<li title="erl_drv_tsd_get">
<a href="erl_driver.html#erl_drv_tsd_get">erl_drv_tsd_get()
              </a></li>
<li title="erl_drv_putenv">
<a href="erl_driver.html#erl_drv_putenv">erl_drv_putenv()
              </a></li>
<li title="erl_drv_getenv">
<a href="erl_driver.html#erl_drv_getenv">erl_drv_getenv()
              </a></li>
</ul>
</li>
<li title="driver_entry">
<a href="driver_entry.html">driver_entry</a></li>
<li title="erts_alloc">
<a href="erts_alloc.html">erts_alloc</a></li>
<li title="erl_nif " expanded="false">erl_nif<ul>
<li>
<a href="erl_nif.html">
                  Top of manual page
                </a></li>
<li title="enif_get_data">
<a href="erl_nif.html#enif_get_data">enif_get_data()
              </a></li>
<li title="enif_alloc">
<a href="erl_nif.html#enif_alloc">enif_alloc()
              </a></li>
<li title="enif_free">
<a href="erl_nif.html#enif_free">enif_free()
              </a></li>
<li title="enif_is_binary">
<a href="erl_nif.html#enif_is_binary">enif_is_binary()
              </a></li>
<li title="enif_inspect_binary">
<a href="erl_nif.html#enif_inspect_binary">enif_inspect_binary()
              </a></li>
<li title="enif_alloc_binary">
<a href="erl_nif.html#enif_alloc_binary">enif_alloc_binary()
              </a></li>
<li title="enif_release_binary">
<a href="erl_nif.html#enif_release_binary">enif_release_binary()
              </a></li>
<li title="enif_get_int">
<a href="erl_nif.html#enif_get_int">enif_get_int()
              </a></li>
<li title="enif_get_ulong">
<a href="erl_nif.html#enif_get_ulong">enif_get_ulong()
              </a></li>
<li title="enif_get_list_cell">
<a href="erl_nif.html#enif_get_list_cell">enif_get_list_cell()
              </a></li>
<li title="enif_make_binary">
<a href="erl_nif.html#enif_make_binary">enif_make_binary()
              </a></li>
<li title="enif_make_badarg">
<a href="erl_nif.html#enif_make_badarg">enif_make_badarg()
              </a></li>
<li title="enif_make_int">
<a href="erl_nif.html#enif_make_int">enif_make_int()
              </a></li>
<li title="enif_make_ulong">
<a href="erl_nif.html#enif_make_ulong">enif_make_ulong()
              </a></li>
<li title="enif_make_atom">
<a href="erl_nif.html#enif_make_atom">enif_make_atom()
              </a></li>
<li title="enif_make_tuple">
<a href="erl_nif.html#enif_make_tuple">enif_make_tuple()
              </a></li>
<li title="enif_make_list">
<a href="erl_nif.html#enif_make_list">enif_make_list()
              </a></li>
<li title="enif_make_list_cell">
<a href="erl_nif.html#enif_make_list_cell">enif_make_list_cell()
              </a></li>
<li title="enif_make_string">
<a href="erl_nif.html#enif_make_string">enif_make_string()
              </a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>driver_entry</h1></center>
  
  <h3>C LIBRARY</h3>
<div class="REFBODY">driver_entry</div>
  <h3>LIBRARY SUMMARY</h3>
<div class="REFBODY">The driver-entry structure used by erlang drivers.</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>As of erts version 5.5.3 the driver interface has been extended
      (see <span class="bold_code">
<a href="driver_entry.html#extended_marker">extended marker</a></span>).
      The extended interface introduce
      <span class="bold_code">
<a href="erl_driver.html#version_management">version management</a></span>,
      the possibility to pass capability flags
      (see <span class="bold_code">
<a href="driver_entry.html#driver_flags">driver flags</a></span>)
      to the runtime system at driver initialization, and some new
      driver API functions.      </p>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>Old drivers (compiled with an <span class="code">erl_driver.h</span> from an
        earlier erts version than 5.5.3) have to be recompiled
        (but does not have to use the extended interface).</p>
    </p></div>
</div>
    <p>The <span class="code">driver_entry</span> structure is a C struct that all erlang
      drivers defines. It contains entry points for the erlang driver
      that are called by the erlang emulator when erlang code accesses
      the driver.</p>
    <p>      
      <a name="emulator"></a>
      The <span class="bold_code">
<a href="driver_entry.html">erl_driver</a></span> driver
      API functions needs a port handle
      that identifies the driver instance (and the port in the
      emulator). This is only passed to the <span class="code">start</span> function, but
      not to the other functions. The <span class="code">start</span> function returns a
      driver-defined handle that is passed to the other functions. A
      common practice is to have the <span class="code">start</span> function allocating
      some application-defined structure and stash the <span class="code">port</span>
      handle in it, to use it later with the driver API functions.</p>
    <p>The driver call-back functions are called synchronously from the
      erlang emulator. If they take too long before completing, they
      can cause timeouts in the emulator. Use the queue or
      asynchronous calls if necessary, since the emulator must be
      responsive.</p>
    <p>The driver structure contains the name of the driver and some
      15 function pointers. These pointers are called at different
      times by the emulator.</p>
    <p>The only exported function from the driver is
      <span class="code">driver_init</span>. This function returns the <span class="code">driver_entry</span>
      structure that points to the other functions in the driver. The
      <span class="code">driver_init</span> function is declared with a macro
      <span class="code">DRIVER_INIT(drivername)</span>. (This is because different OS's
      have different names for it.)</p>
    <p>When writing a driver in C++, the driver entry should be of
      <span class="code">"C"</span> linkage. One way to do this is to put this line
      somewhere before the driver entry:
      <span class="code">extern "C" DRIVER_INIT(drivername);</span>.</p>
    <p>When the driver has passed the <span class="code">driver_entry</span> over to
      the emulator, the driver is <strong>not</strong> allowed to modify the
      <span class="code">driver_entry</span>.</p>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>Do <strong>not</strong> declare the <span class="code">driver_entry</span><span class="code">const</span>. This since the emulator needs to
        modify the <span class="code">handle</span>, and the <span class="code">handle2</span>
        fields. A statically allocated, and <span class="code">const</span>
        declared <span class="code">driver_entry</span> may be located in
        read only memory which will cause the emulator
        to crash.</p>
    </p></div>
</div>
  </p></div>
  <h3><a name="id2359709">DATA TYPES</a></h3>
<div class="REFBODY">
    
    <dl>
    <dt><strong><strong>ErlDrvEntry</strong></strong></dt>
    <dd>
    <p></p>
    <div class="example"><pre>
typedef struct erl_drv_entry {
    int (*init)(void);          /* called at system start up for statically
                                   linked drivers, and after loading for
                                   dynamically loaded drivers */ 
#ifndef ERL_SYS_DRV
    ErlDrvData (*start)(ErlDrvPort port, char *command);
                                /* called when open_port/2 is invoked.
                                   return value -1 means failure. */
#else
    ErlDrvData (*start)(ErlDrvPort port, char *command, SysDriverOpts* opts);
                                /* special options, only for system driver */
#endif
    void (*stop)(ErlDrvData drv_data);
                                /* called when port is closed, and when the
                                   emulator is halted. */
    void (*output)(ErlDrvData drv_data, char *buf, int len);
                                /* called when we have output from erlang to 
                                   the port */
    void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event); 
                                /* called when we have input from one of 
                                   the driver's handles) */
    void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event);  
                                /* called when output is possible to one of 
                                   the driver's handles */
    char *driver_name;          /* name supplied as command 
                                   in open_port XXX ? */
    void (*finish)(void);       /* called before unloading the driver -
                                   DYNAMIC DRIVERS ONLY */
    void *handle;               /* Reserved -- Used by emulator internally */
    int (*control)(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen); 
                                /* "ioctl" for drivers - invoked by 
                                   port_control/3) */
    void (*timeout)(ErlDrvData drv_data);        /* Handling of timeout in driver */
    void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev);
                                /* called when we have output from erlang
                                   to the port */
    void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data);
    void (*flush)(ErlDrvData drv_data);
                                /* called when the port is about to be 
                                   closed, and there is data in the 
                                   driver queue that needs to be flushed
                                   before 'stop' can be called */
    int (*call)(ErlDrvData drv_data, unsigned int command, char *buf, 
                   int len, char **rbuf, int rlen, unsigned int *flags); 
                                /* Works mostly like 'control', a syncronous
                                   call into the driver. */
    void (*event)(ErlDrvData drv_data, ErlDrvEvent event,
                  ErlDrvEventData event_data);
                                /* Called when an event selected by 
                                   driver_event() has occurred */
    int extended_marker;        /* ERL_DRV_EXTENDED_MARKER */
    int major_version;          /* ERL_DRV_EXTENDED_MAJOR_VERSION */
    int minor_version;          /* ERL_DRV_EXTENDED_MINOR_VERSION */
    int driver_flags;           /* ERL_DRV_FLAGs */
    void *handle2;              /* Reserved -- Used by emulator internally */
    void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor);
                                /* Called when a process monitor fires */
    void (*stop_select)(ErlDrvEvent event, void* reserved);
                                /* Called to close an event object */
 } ErlDrvEntry;
    </pre></div>
    <p></p>
    <dl>
      <dt><strong><a name="init"></a>int (*init)(void)</strong></dt>
      <dd>        
        <p>This is called directly after the driver has been loaded by
          <span class="code">erl_ddll:load_driver/2</span>. (Actually when the driver is
          added to the driver list.) The driver should return 0, or if
          the driver can't initialize, -1.</p>
      </dd>
      <dt><strong><a name="start"></a>int (*start)(ErlDrvPort port, char* command)</strong></dt>
      <dd>
        <p>This is called when the driver is instantiated, when
          <span class="code">open_port/2</span> is called. The driver should return a
          number &gt;= 0 or a pointer, or if the driver can't be started,
          one of three error codes should be returned:</p>
        <p>ERL_DRV_ERROR_GENERAL - general error, no error code</p>
        <p>ERL_DRV_ERROR_ERRNO - error with error code in erl_errno</p>
        <p>ERL_DRV_ERROR_BADARG - error, badarg</p>
        <p>If an error code is returned, the port isn't started.</p>
      </dd>
      <dt><strong><a name="stop"></a>void (*stop)(ErlDrvData drv_data)</strong></dt>
      <dd>
        <p>This is called when the port is closed, with
          <span class="code">port_close/1</span> or <span class="code">Port ! {self(), close}</span>. Note
          that terminating the port owner process also closes the
          p\011  port.</p>
      </dd>
      <dt><strong><a name="output"></a>void (*output)(ErlDrvData drv_data, char *buf, int len)</strong></dt>
      <dd>
        <p>This is called when an erlang process has sent data to the
          port. The data is pointed to by <span class="code">buf</span>, and is
          <span class="code">len</span> bytes.  Data is sent to the port with <span class="code">Port ! {self(), {command, Data}}</span>, or with
          <span class="code">port_command/2</span>. Depending on how the port was opened,
          it should be either a list of integers 0...255 or a
          binary. See <span class="code">open_port/3</span> and <span class="code">port_command/2</span>.</p>
      </dd>
      <dt><strong><a name="ready_input"></a>void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event)</strong></dt>
      <dt><strong><a name="ready_output"></a>void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event)</strong></dt>
      <dd>
        <p>This is called when a driver event (given in the
          <span class="code">event</span> parameter) is signaled. This is used to help
          asynchronous drivers "wake up" when something happens.</p>
        <p>On unix the <span class="code">event</span> is a pipe or socket handle (or
          something that the <span class="code">select</span> system call understands).</p>
        <p>On Windows the <span class="code">event</span> is an Event or Semaphore (or
          something that the <span class="code">WaitForMultipleObjects</span> API
          function understands). (Some trickery in the emulator allows
          more than the built-in limit of 64 <span class="code">Events</span> to be used.)</p>
        <p>To use this with threads and asynchronous routines, create a
          pipe on unix and an Event on Windows. When the routine
          completes, write to the pipe (use <span class="code">SetEvent</span> on
          Windows), this will make the emulator call
          <span class="code">ready_input</span> or <span class="code">ready_output</span>.</p>
      </dd>
      <dt><strong><a name="driver_name"></a>char *driver_name</strong></dt>
      <dd>
        <p>This is the name of the driver, it must correspond to the
          atom used in <span class="code">open_port</span>, and the name of the driver
          library file (without the extension).</p>
      </dd>
      <dt><strong><a name="finish"></a>void (*finish)(void)</strong></dt>
      <dd>
        <p>This function is called by the <span class="code">erl_ddll</span> driver when the
          driver is unloaded. (It is only called in dynamic drivers.)</p>
        <p>The driver is only unloaded as a result of calling
          <span class="code">unload_driver/1</span>, or when the emulator halts.</p>
      </dd>
      <dt><strong>void *handle</strong></dt>
      <dd>
        <p>This field is reserved for the emulators internal use. The
          emulator will modify this field; therefore, it is important
          that the <span class="code">driver_entry</span> isn't declared <span class="code">const</span>.</p> 
      </dd>
      <dt><strong><a name="control"></a>int (*control)(ErlDrvData drv_data, unsigned int command, char *buf,  int len, char **rbuf, int rlen)</strong></dt>
      <dd>
        <p>This is a special routine invoked with the erlang function
          <span class="code">port_control/3</span>. It works a little like an "ioctl" for
          erlang drivers. The data given to <span class="code">port_control/3</span>
          arrives in <span class="code">buf</span> and <span class="code">len</span>. The driver may send
          data back, using <span class="code">*rbuf</span> and <span class="code">rlen</span>.</p>
        <p>This is the fastest way of calling a driver and get a
          response. It won't make any context switch in the erlang
          emulator, and requires no message passing. It is suitable
          for calling C function to get faster execution, when erlang
          is too slow.</p>
        <p>If the driver wants to return data, it should return it in
          <span class="code">rbuf</span>. When <span class="code">control</span> is called,
          <span class="code">*rbuf</span> points to a default buffer of <span class="code">rlen</span> bytes, which
          can be used to return data. Data is returned different depending on
          the port control flags (those that are set with
          <span class="bold_code">
<a href="erl_driver.html#set_port_control_flags">set_port_control_flags</a></span>).
          </p>
        <p>If the flag is set to <span class="code">PORT_CONTROL_FLAG_BINARY</span>,
           a binary will be returned. Small binaries can be returned by writing
           the raw data into the default buffer. A binary can also be
           returned by setting <span class="code">*rbuf</span> to point to a binary allocated with
          <span class="bold_code">
<a href="erl_driver.html#driver_alloc_binary">driver_alloc_binary</a></span>.
          This binary will be freed automatically after <span class="code">control</span> has returned.
          The driver can retain the binary for <strong>read only</strong> access with
          <span class="bold_code">
<a href="erl_driver.html#driver_binary_inc_refc">driver_binary_inc_refc</a></span> to be freed later with
          <span class="bold_code">
<a href="erl_driver.html#driver_free_binary">driver_free_binary</a></span>.
          It is never allowed to alter the binary after <span class="code">control</span> has returned.
          If <span class="code">*rbuf</span> is set to NULL, an empty list will be returned.
          </p>
        <p>If the flag is set to <span class="code">0</span>, data is returned as a
          list of integers. Either use the default buffer or set
          <span class="code">*rbuf</span> to point to a larger buffer allocated with
          <span class="bold_code">
<a href="erl_driver.html#driver_alloc">driver_alloc</a></span>.
          The buffer will be freed automatically after <span class="code">control</span> has returned.</p>
        <p>Using binaries is faster if more than a few bytes are returned.</p>
        <p>The return value is the number of bytes returned in
          <span class="code">*rbuf</span>.</p>
      </dd>
      <dt><strong><a name="timeout"></a>void (*timeout)(ErlDrvData drv_data)</strong></dt>
      <dd>
        <p>This function is called any time after the driver's timer
          reaches 0. The timer is activated with
          <span class="code">driver_set_timer</span>. There are no priorities or ordering
          among drivers, so if several drivers time out at the same
          time, any one of them is called first.</p>
      </dd>
      <dt><strong><a name="outputv"></a>void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev)</strong></dt>
      <dd>
        <p>This function is called whenever the port is written to. If
          it is <span class="code">NULL</span>, the <span class="code">output</span> function is called
          instead. This function is faster than <span class="code">output</span>, because
          it takes an <span class="code">ErlIOVec</span> directly, which requires no
          copying of the data. The port should be in binary mode, see
          <span class="code">open_port/2</span>.</p>
        <p>The <span class="code">ErlIOVec</span> contains both a <span class="code">SysIOVec</span>,
          suitable for <span class="code">writev</span>, and one or more binaries. If
          these binaries should be retained, when the driver returns
          from <span class="code">outputv</span>, they can be queued (using <span class="bold_code">
<a href="erl_driver.html#driver_enq_bin">driver_enq_bin</a></span>
          for instance), or if they are kept in a static or global
          variable, the reference counter can be incremented.</p>
      </dd>
      <dt><strong><a name="ready_async"></a>void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data)</strong></dt>
      <dd>
        <p>This function is called after an asynchronous call has
          completed. The asynchronous call is started with <span class="bold_code">
<a href="erl_driver.html#driver_async">driver_async</a></span>.
          This function is called from the erlang emulator thread, as
          opposed to the asynchronous function, which is called in
          some thread (if multithreading is enabled).</p>
      </dd>
      <dt><strong><a name="call"></a>int (*call)(ErlDrvData drv_data, unsigned int command, char *buf, int len, char **rbuf, int rlen, unsigned int *flags)</strong></dt>
      <dd>
        <p>This function is called from <span class="code">erlang:port_call/3</span>. It
          works a lot like the <span class="code">control</span> call-back, but uses the
          external term format for input and output.</p>
        <p><span class="code">command</span> is an integer, obtained from the call from
          erlang (the second argument to <span class="code">erlang:port_call/3</span>).</p>
        <p><span class="code">buf</span> and <span class="code">len</span> provide the arguments to the call
          (the third argument to <span class="code">erlang:port_call/3</span>). They can
          be decoded using <span class="code">ei</span> functions.</p>
        <p><span class="code">rbuf</span> points to a return buffer, <span class="code">rlen</span> bytes
          long. The return data should be a valid erlang term in the
          external (binary) format. This is converted to an erlang
          term and returned by <span class="code">erlang:port_call/3</span> to the
          caller.  If more space than <span class="code">rlen</span> bytes is needed to
          return data, <span class="code">*rbuf</span> can be set to memory allocated with
          <span class="code">driver_alloc</span>. This memory will be freed automatically
          after <span class="code">call</span> has returned.</p>
        <p>The return value is the number of bytes returned in
          <span class="code">*rbuf</span>. If <span class="code">ERL_DRV_ERROR_GENERAL</span> is returned
          (or in fact, anything &lt; 0), <span class="code">erlang:port_call/3</span> will
          throw a <span class="code">BAD_ARG</span>.</p>
      </dd>
      <dt><strong>void (*event)(ErlDrvData drv_data, ErlDrvEvent event, ErlDrvEventData event_data)</strong></dt>
      <dd>
        <p>Intentionally left undocumented.</p>
      </dd>
      <dt><strong><a name="extended_marker"></a>int extended_marker</strong></dt>
      <dd>
        <p>
          This field should either be equal to <span class="code">ERL_DRV_EXTENDED_MARKER</span>
          or <span class="code">0</span>. An old driver (not aware of the extended driver
          interface) should set this field to <span class="code">0</span>. If this field is
          equal to <span class="code">0</span>, all the fields following this field also
          <strong>have</strong> to be <span class="code">0</span>, or <span class="code">NULL</span> in case it is a
          pointer field.
        </p>
      </dd>
      <dt><strong>int major_version</strong></dt>
      <dd>
        <p>This field should equal <span class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</span> if
          the <span class="code">extended_marker</span> field equals
          <span class="code">ERL_DRV_EXTENDED_MARKER</span>.</p> 
      </dd>
      <dt><strong>int minor_version</strong></dt>
      <dd>
        <p>
          This field should equal <span class="code">ERL_DRV_EXTENDED_MINOR_VERSION</span> if
          the <span class="code">extended_marker</span> field equals
          <span class="code">ERL_DRV_EXTENDED_MARKER</span>.
        </p>
      </dd>
      <dt><strong><a name="driver_flags"></a>int driver_flags</strong></dt>
      <dd>
        <p>This field is used to pass driver capability information to the
          runtime system. If the <span class="code">extended_marker</span> field equals
          <span class="code">ERL_DRV_EXTENDED_MARKER</span>, it should contain <span class="code">0</span> or
          driver flags (<span class="code">ERL_DRV_FLAG_*</span>) ored bitwise. Currently
          the following driver flags exist:
        </p>
        <dl>
          <dt><strong><span class="code">ERL_DRV_FLAG_USE_PORT_LOCKING</span></strong></dt>
          <dd>
            The runtime system will use port level locking on
            all ports executing this driver instead of driver
            level locking when the driver is run in a runtime
            system with SMP support. For more information see the
            <span class="bold_code">
<a href="erl_driver.html#smp_support">erl_driver</a></span> 
            documentation.
          </dd> 
          <dt><strong><span class="code">ERL_DRV_FLAG_SOFT_BUSY</span></strong></dt>
          <dd>
            Marks that driver instances can handle being called
	    in the <span class="bold_code">
<a href="#output">output</a></span> and/or
	    <span class="bold_code">
<a href="#outputv">outputv</a></span> callbacks even
	    though a driver instance has marked itself as busy (see
            <span class="bold_code">
<a href="erl_driver.html#set_busy_port">set_busy_port()</a></span>).
	    Since erts version 5.7.4 this flag is required for drivers used
	    by the Erlang distribution (the behaviour has always been
	    required by drivers used by the distribution).
          </dd>
        </dl> 
      </dd>
      <dt><strong>void *handle2</strong></dt>
      <dd>
        <p>
          This field is reserved for the emulators internal use. The
          emulator will modify this field; therefore, it is important
          that the <span class="code">driver_entry</span> isn't declared <span class="code">const</span>.
        </p>
      </dd>
      <dt><strong><a name="process_exit"></a>void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor)</strong></dt>
      <dd>
        <p>This callback is called when a monitored process exits. The
          <span class="code">drv_data</span> is the data associated with the port for which
          the process is monitored (using <span class="bold_code">
<a href="erl_driver.html#driver_monitor_process">driver_monitor_process</a></span>)
          and the <span class="code">monitor</span> corresponds to the <span class="code">ErlDrvMonitor</span> 
          structure filled
          in when creating the monitor. The driver interface function
          <span class="bold_code">
<a href="erl_driver.html#driver_get_monitored_process">driver_get_monitored_process</a></span>
          can be used to retrieve the process id of the exiting process as
          an <span class="code">ErlDrvTermData</span>.</p>
      </dd>
      <dt><strong><a name="stop_select"></a>void (*stop_select)(ErlDrvEvent event, void* reserved)</strong></dt>
      <dd>
        <p>This function is called on behalf of
           <span class="bold_code">
<a href="erl_driver.html#driver_select">driver_select</a></span>
           when it is safe to close an event object.</p>
        <p>A typical implementation on Unix is to do
           <span class="code">close((int)event)</span>.</p>
        <p>Argument <span class="code">reserved</span> is intended for future use and should be ignored.</p>
        <p>In contrast to most of the other call-back functions,
           <span class="code">stop_select</span> is called independent of any port. No
           <span class="code">ErlDrvData</span> argument is passed to the function. No
           driver lock or port lock is guaranteed to be held. The port that
           called <span class="code">driver_select</span> might even be closed at the
           time <span class="code">stop_select</span> is called. But it could also be
           the case that <span class="code">stop_select</span> is called directly by
           <span class="code">driver_select</span>.</p>
        <p>It is not allowed to call any functions in the
           <span class="bold_code">
<a href="erl_driver.html">driver API</a></span> from
           <span class="code">stop_select</span>. This strict limitation is due to the
           volatile context that <span class="code">stop_select</span> may be called.</p>
      </dd>
    </dl>
    </dd>
    </dl>
  </div>
  <h3><a name="id2360850">SEE ALSO</a></h3>
<div class="REFBODY">
    
    <p><span class="bold_code">
<a href="erl_driver.html">erl_driver(3)</a></span>, 
      <span class="bold_code">
<a href="erl_ddll.html">erl_ddll(3)</a></span>,
      <span class="bold_code">
<a href="erlang.html">erlang(3)</a></span>,
      kernel(3)</p>
  </div>
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2009 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3045895-1";
urchinTracker();
</script> 
</body>
</html>
